(window.webpackJsonp=window.webpackJsonp||[]).push([[1],{20:function(a){a.exports=JSON.parse('[{"date":1571529600000,"title":"CSS中的矩阵变换","fileName":"CSS中的矩阵变换","content":"<p><img src=\\"https://cdn.bigliao.com/33f0c957f9047c831047a585346ce3b4.jpg\\" alt=\\"\\"></p><p><code>transform</code> 是 CSS3 中加入的用于控制形变的属性，搞前端肯定知道怎么用（不知道的去看看 <a href=\\"https://developer.mozilla.org/en-US/docs/Web/CSS/transform\\">MDN</a> 上的说明）。就是可以让你的元素进行<em>旋转</em>、<em>移动</em>、<em>缩放</em>等操作。</p>","path":"/blog/CSS中的矩阵变换.html"},{"date":1572134400000,"title":"Chrome浏览器新原生文件接口","fileName":"Chrome浏览器新原生文件接口","content":"<p>Chrome浏览器最新的原生文件文件系统接口 (Native File System API) ，目前还在试验阶段，它可以让 Web 应用直接读写设备上的文件。</p><p>为了安全问题，Web 程序是不允许直接访问文件系统的。否则黑客可直接通过网页来获取你的文件内容了。所以，无论是读取文件内容，还是保存文件，都要经过用户允许。比如常用的上传和下载文件，都会出现一个弹窗让用户自己选择。这也是 Web 程序体验不如原生程序的地方。假如 Web 程序可以像原生程序一个直接读写文件，那么 Web 应用将有更多的机会替代原生应用，比如 IDEs，图片或者视频编辑器，文字编辑器等。</p>","path":"/blog/Chrome浏览器新原生文件接口.html"},{"date":1564272000000,"title":"[工具篇] iTerm2——打造漂亮的Mac终端","fileName":"[工具篇]iTerm2——打造漂亮的Mac命令行工具","content":"<p>你可以不会几个命令，但你必须要有一个好看的命令行工具。</p><p>本文没啥技术含量，就是介绍如何安装一个漂亮又好用的命令行工具。网上已经有很多介绍 iTerm2 的文章了，我这篇是记录一下自己的配置。软件只适用于 Mac 电脑，用 Windows 的同学 可以去用 <code>cmder</code>。</p>","path":"/blog/[工具篇]iTerm2——打造漂亮的Mac命令行工具.html"},{"date":1563494400000,"title":"[算法导论]第三章-函数的增长","fileName":"[算法导论]第三章-函数的增长","content":"<p>本章主要讲了渐近符号，初看晦涩难懂，其实主要是数学公式太多，“不求甚解”的态度就很好...</p><p>主要讲了三个渐近记号，对应三种情况，<span class=\\"katex\\"><span class=\\"katex-mathml\\"><math><semantics><mrow><mi>g</mi><mo stretchy=\\"false\\">(</mo><mi>n</mi><mo stretchy=\\"false\\">)</mo></mrow><annotation encoding=\\"application/x-tex\\">g(n)</annotation></semantics></math></span><span class=\\"katex-html\\" aria-hidden=\\"true\\"><span class=\\"base\\"><span class=\\"strut\\" style=\\"height:1em;vertical-align:-0.25em;\\"></span><span class=\\"mord mathdefault\\" style=\\"margin-right:0.03588em;\\">g</span><span class=\\"mopen\\">(</span><span class=\\"mord mathdefault\\">n</span><span class=\\"mclose\\">)</span></span></span></span> 分别是 <span class=\\"katex\\"><span class=\\"katex-mathml\\"><math><semantics><mrow><mi>f</mi><mo stretchy=\\"false\\">(</mo><mi>n</mi><mo stretchy=\\"false\\">)</mo></mrow><annotation encoding=\\"application/x-tex\\">f(n)</annotation></semantics></math></span><span class=\\"katex-html\\" aria-hidden=\\"true\\"><span class=\\"base\\"><span class=\\"strut\\" style=\\"height:1em;vertical-align:-0.25em;\\"></span><span class=\\"mord mathdefault\\" style=\\"margin-right:0.10764em;\\">f</span><span class=\\"mopen\\">(</span><span class=\\"mord mathdefault\\">n</span><span class=\\"mclose\\">)</span></span></span></span> 的：</p>","path":"/blog/[算法导论]第三章-函数的增长.html"},{"date":1566691200000,"title":"[算法导论]第五章-概率分析与随机算法","fileName":"[算法导论]第五章-概率分析与随机算法","content":"<p>上帝从不掷骰子</p><p>把《算法导论》里的问题简化描述一下是这样的：</p><p>你准备雇用一个助理，原则是只用最好的，所以每面试到一个比当前助理更好的候选人，你就会用他替换，而且你打算一直面试下去。每次面试都要花费少额费用，而每次雇用要花费较大额的费用（遣散费和雇用费）。问题是计算总花费。</p>","path":"/blog/[算法导论]第五章-概率分析与随机算法.html"},{"date":1567382400000,"title":"[算法导论]第六章-堆排序","fileName":"[算法导论]第六章-堆排序","content":"<p>万物始于混沌</p><p>定义</p><p>左右孩子</p>","path":"/blog/[算法导论]第六章-堆排序.html"},{"date":1566086400000,"title":"[算法导论]第四章-主定理","fileName":"[算法导论]第四章-主定理","content":"<p>上帝说，要有递归，于是有了主定理。</p><p>分治法的三个步骤是：<strong>分</strong>、<strong>治</strong>、<strong>合</strong>，时间复杂度 <span class=\\"katex\\"><span class=\\"katex-mathml\\"><math><semantics><mrow><mi>T</mi><mo stretchy=\\"false\\">(</mo><mi>n</mi><mo stretchy=\\"false\\">)</mo></mrow><annotation encoding=\\"application/x-tex\\">T(n)</annotation></semantics></math></span><span class=\\"katex-html\\" aria-hidden=\\"true\\"><span class=\\"base\\"><span class=\\"strut\\" style=\\"height:1em;vertical-align:-0.25em;\\"></span><span class=\\"mord mathdefault\\" style=\\"margin-right:0.13889em;\\">T</span><span class=\\"mopen\\">(</span><span class=\\"mord mathdefault\\">n</span><span class=\\"mclose\\">)</span></span></span></span> 容易用递推式表示。</p>","path":"/blog/[算法导论]第四章-主定理.html"},{"date":1565481600000,"title":"[算法导论]第四章-递推式求解","fileName":"[算法导论]第四章-递推式求解","content":"<p>如果说学计算机必备什么数学知识的话，那大概就是数学归纳法吧。</p><p>分治法可以总结为一下三个步骤：</p><p>分治法在程序中表现就是<em>递归</em>，像<em>归并排序</em>、<em>快速排序</em>、<em>最大子数组问题</em>，用的都是递归的方法。通常我们很容易写出递归的时间复杂度的<strong>递推式</strong>，比如<em>最大子数组问题</em>的时间复杂度 <span class=\\"katex\\"><span class=\\"katex-mathml\\"><math><semantics><mrow><mi>T</mi><mo stretchy=\\"false\\">(</mo><mi>n</mi><mo stretchy=\\"false\\">)</mo></mrow><annotation encoding=\\"application/x-tex\\">T(n)</annotation></semantics></math></span><span class=\\"katex-html\\" aria-hidden=\\"true\\"><span class=\\"base\\"><span class=\\"strut\\" style=\\"height:1em;vertical-align:-0.25em;\\"></span><span class=\\"mord mathdefault\\" style=\\"margin-right:0.13889em;\\">T</span><span class=\\"mopen\\">(</span><span class=\\"mord mathdefault\\">n</span><span class=\\"mclose\\">)</span></span></span></span> 为：</p>","path":"/blog/[算法导论]第四章-递推式求解.html"},{"date":1564358400000,"title":"[翻译]REST vs. GraphQL","fileName":"[翻译]REST vs. GraphQL","content":"<p><em>This post has been published first on</em> <a href=\\"http://codingthesmartway.com/\\"><em>CodingTheSmartWay.com</em></a></p><p><a href=\\"https://www.youtube.com/channel/UCLXQoK41TOcIsWtY-BgB_kQ?sub_confirmation=1\\"><strong>去 YouTube 上订阅原作者</strong></a></p>","path":"/blog/[翻译]REST vs. GraphQL.html"},{"date":1564704000000,"title":"webpack揭秘(1)——初探","fileName":"webpack揭秘(1)","content":"<p>放心，其实我也记不住webpack的配置:)</p><p><img src=\\"https://cdn.bigliao.com/e792e85d0a8353d919ee7416af469716.png\\" alt=\\"webpack banner\\"></p><p>这张来自 webpack <a href=\\"https://webpack.js.org/\\">官网</a>的配图已经形象地告诉我们 webpack 是做什么用的：把一堆相互依赖的模块（各种类型的文件）打包成静态资源文件。</p>","path":"/blog/webpack揭秘(1).html"},{"date":1566259200000,"title":"webpack揭秘(2)——核心概念","fileName":"webpack揭秘(2)","content":"<p>我不生产内容，我只是文档的搬运工。</p><p><code>entry</code> 就是 webpack 打包的入口，它指定了 webpack 从哪个文件开始着手，然后顺着这个入口文件开始查找依赖，根据得到的<strong>依赖关系图</strong>（dependancy graph）把所有所需的代码打包起来。</p>","path":"/blog/webpack揭秘(2).html"}]')}}]);